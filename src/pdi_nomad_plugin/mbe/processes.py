import json
import random
import pandas as pd
import numpy as np
import plotly.graph_objects as go
from nomad.config import config
from nomad.datamodel import EntryArchive
from nomad.datamodel.data import ArchiveSection, EntryData
from nomad.datamodel.hdf5 import HDF5Reference
from nomad.datamodel.metainfo.annotations import (
    ELNAnnotation,
    ELNComponentEnum,
    H5WebAnnotation,
    SectionProperties,
)
from nomad.datamodel.metainfo.basesections import (
    Component,
    CompositeSystem,
    CompositeSystemReference,
    Experiment,
    Process,
    ProcessStep,
    SectionReference,
    System,
    SystemComponent,
)
from nomad.datamodel.metainfo.plot import (
    PlotlyFigure,
    PlotSection,
)
from nomad.datamodel.metainfo.workflow import (
    Link,
)
from nomad.metainfo import (
    Datetime,
    Quantity,
    Reference,
    SchemaPackage,
    Section,
    SubSection,
)
from nomad_material_processing.general import (
    TimeSeries,
    SubstrateReference,
)
from nomad_material_processing.vapor_deposition.cvd.general import (
    Rotation,
)
from nomad_material_processing.vapor_deposition.general import (
    ChamberEnvironment,
    Pressure,
    SubstrateHeater,
    Temperature,
    VaporDeposition,
    VaporDepositionStep,
)
from nomad_material_processing.vapor_deposition.pvd.general import (
    PVDSampleParameters,
)
from nomad_measurements.general import ActivityReference
from nomad_measurements.xrd.schema import ELNXRayDiffraction

from pdi_nomad_plugin.characterization.schema import (
    AFMmeasurement,
    LaserReflectance,
    LightMicroscope,
    MassSpectrometry,
    Pyrometry,
    RHEEDMeasurement,
)
from pdi_nomad_plugin.general.schema import (
    PDIMBECategory,
    SampleCutPDI,
)

from pdi_nomad_plugin.mbe.materials import (
    ThinFilmStackMbePDI
)

from pdi_nomad_plugin.mbe.instrument import (
    FilledSubstrateHolderPDIReference,
    Shutter,
    SourcePDI,
)
from pdi_nomad_plugin.utils import (
    create_archive,
    handle_section,
    link_growth_process,
    set_sample_status,
)

configuration = config.get_plugin_entry_point('pdi_nomad_plugin.mbe:processes_schema')

m_package = SchemaPackage()


def random_rgb():
    return (
        f'{random.randint(0, 255)}, {random.randint(0, 255)}, {random.randint(0, 255)}'
    )


def hdf5_2_datetime(archive, hdf5_dataset_path):
    timestamp_string_array = HDF5Reference.read_dataset(
        archive, hdf5_dataset_path
    ) 
    timestamp_string_list = [ts.decode('utf-8') for ts in timestamp_string_array]
    return pd.to_datetime(
        timestamp_string_list, format='ISO8601') #2024-11-21 00:19:37.291000+01:00

class SystemComponentPDI(SystemComponent):
    """
    A section for describing a system component and its role in a composite system.
    """

    molar_concentration = Quantity(
        type=np.float64,
        description='The solvent for the current substance.',
        unit='mol/liter',
        a_eln=dict(component='NumberEditQuantity', defaultDisplayUnit='mol/liter'),
        a_tabular={
            'name': 'Precursors/Molar conc',
            # "unit": "gram"
        },
    )
    system = Quantity(
        type=Reference(System.m_def),
        description='A reference to the component system.',
        a_eln=dict(component='ReferenceEditQuantity'),
    )


class PrecursorsPreparationPDI(Process, EntryData):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section(
        a_eln={
            'hide': [
                'instruments',
                'steps',
                'samples',
            ]
        },
        label_quantity='name',
        categories=[PDIMBECategory],
        label='PrecursorsPreparation',
    )
    data_file = Quantity(
        type=str,
        description='Upload here the spreadsheet file containing the deposition control data',
        a_browser={'adaptor': 'RawFileAdaptor'},
        a_eln={'component': 'FileEditQuantity'},
    )
    lab_id = Quantity(
        type=str,
        description='FILL',
        a_tabular={'name': 'Precursors/Sample ID'},
        a_eln={'component': 'StringEditQuantity', 'label': 'Sample ID'},
    )
    tags = Quantity(
        type=str,
        shape=['*'],
        description='Searchable tags for this entry. Use Explore tab for searching.',
        a_eln=ELNAnnotation(
            component='StringEditQuantity',
        ),
    )
    name = Quantity(
        type=str,
        description='FILL',
        a_tabular={'name': 'Precursors/number'},
        a_eln={
            'component': 'StringEditQuantity',
        },
    )
    description = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )
    flow_titanium = Quantity(  # TODO make this a single flow
        type=np.float64,
        description='FILL THE DESCRIPTION',
        a_tabular={'name': 'Precursors/Set flow Ti'},
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'ml / minute'},
        unit='ml / minute',
    )
    flow_calcium = Quantity(
        type=np.float64,
        description='FILL THE DESCRIPTION',
        a_tabular={'name': 'Precursors/Set flow Ca'},
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'ml / minute'},
        unit='ml / minute',
    )
    # precursors = SubSection(
    #     section_def=SystemComponent,
    #     description="""
    #     A precursor used in MBE. It can be a solution, a gas, or a solid.
    #     """,
    #     repeats=True,
    # )
    components = SubSection(
        description="""
        A list of all the components of the composite system containing a name, reference
        to the system section and mass of that component.
        """,
        section_def=Component,
        repeats=True,
    )


class PrecursorsPreparationPDIReference(ActivityReference):
    """
    A section used for referencing a PrecursorsPreparationPDI.
    """

    m_def = Section(
        label='PrecursorsPreparationReference',
    )
    reference = Quantity(
        type=PrecursorsPreparationPDI,
        description='A reference to a NOMAD `PrecursorsPreparationPDI` entry.',
        a_eln=ELNAnnotation(
            component='ReferenceEditQuantity',
            label='PrecursorsPreparationPDI Reference',
        ),
    )


class PyrometryReference(SectionReference):
    """
    A section used for referencing a pyrometry.
    """

    reference = Quantity(
        type=Pyrometry,
        description='A reference to a NOMAD `Pyrometry` entry.',
        a_eln=ELNAnnotation(
            component='ReferenceEditQuantity',
            label='Pyrometry Reference',
        ),
    )


class LaserReflectanceReference(SectionReference):
    """
    A section used for referencing a LaserReflectance.
    """

    reference = Quantity(
        type=LaserReflectance,
        description='A reference to a NOMAD `LaserReflectance` entry.',
        a_eln=ELNAnnotation(
            component='ReferenceEditQuantity',
            label='Laser Reflectance Reference',
        ),
    )


class HallMeasurementReference(SectionReference):
    """
    A section used for referencing a HallMeasurement.
    The class is taken from the dedicated Lakeshore plugin
    """

    reference = Quantity(
        type=ArchiveSection,
        description='A reference to a NOMAD `HallMeasurement` entry.',
        a_eln=ELNAnnotation(
            component='ReferenceEditQuantity',
            label='Hall Measurement Reference',
        ),
    )


class AFMmeasurementReference(SectionReference):
    """
    A section used for referencing a AFMmeasurement.
    """

    reference = Quantity(
        type=AFMmeasurement,
        description='A reference to a NOMAD `AFMmeasurement` entry.',
        a_eln=ELNAnnotation(
            component='ReferenceEditQuantity',
            label='AFM Measurement Reference',
        ),
    )


class MassSpectrometryReference(SectionReference):
    """
    A section used for referencing a MassSpectrometry.
    """

    reference = Quantity(
        type=MassSpectrometry,
        description='A reference to a NOMAD `MassSpectrometry` entry.',
        a_eln=ELNAnnotation(
            component='ReferenceEditQuantity',
            label='MassSpectrometry Measurement Reference',
        ),
    )


class RHEEDReference(SectionReference):
    """
    RHEED measurement reference
    """

    reference = Quantity(
        type=RHEEDMeasurement,
        description='A reference to a NOMAD `RHEEDMeasurement` entry.',
        a_eln=ELNAnnotation(
            component='ReferenceEditQuantity',
            label='RHEEDMeasurement Measurement Reference',
        ),
    )


class LiMimeasurementReference(SectionReference):
    """
    A section used for referencing a LightMicroscope.
    """

    reference = Quantity(
        type=LightMicroscope,
        description='A reference to a NOMAD `LightMicroscope` entry.',
        a_eln=ELNAnnotation(
            component='ReferenceEditQuantity',
            label='Light Microscope Measurement Reference',
        ),
    )


class XRDmeasurementReference(SectionReference):
    """
    A section used for referencing a LightMicroscope.
    """

    sample_id = Quantity(
        type=str,
        description='The sample to be linked within the XRD measurement',
        a_eln=ELNAnnotation(
            component=ELNComponentEnum.StringEditQuantity,
        ),
    )
    reference = Quantity(
        type=ELNXRayDiffraction,
        description='A reference to a NOMAD `ELNXRayDiffraction` entry.',
        a_eln=ELNAnnotation(
            component='ReferenceEditQuantity',
            label='XRD Measurement Reference',
        ),
    )
    phase = Quantity(
        type=str,
        description='Phase type obtained from HRXRD',
        a_eln=ELNAnnotation(
            component=ELNComponentEnum.StringEditQuantity,
        ),
    )
    peak_position_2theta = Quantity(
        type=np.float64,
        description='Peak Position - 2theta',
        a_eln=ELNAnnotation(
            component=ELNComponentEnum.NumberEditQuantity,
        ),
        unit='degree',
    )
    peak_fwhm_2theta = Quantity(
        type=np.float64,
        description='Peak Position - 2theta',
        a_eln=ELNAnnotation(
            component=ELNComponentEnum.NumberEditQuantity,
        ),
        unit='degree',
    )
    peak_position_omega = Quantity(
        type=np.float64,
        description='Peak Position - Omega',
        a_eln=ELNAnnotation(
            component=ELNComponentEnum.NumberEditQuantity,
        ),
        unit='degree',
    )
    peak_fwhm_rocking_curve = Quantity(
        type=str,
        description='Peak FWHM Rocking Curve',
        a_eln=ELNAnnotation(
            component=ELNComponentEnum.StringEditQuantity,
        ),
    )
    reflection = Quantity(
        type=str,
        description='Peak FWHM Rocking Curve',
        a_eln={'component': 'StringEditQuantity'},
    )
    description = Quantity(
        type=str,
        description='Notes and comments.',
        a_eln=ELNAnnotation(
            component=ELNComponentEnum.RichTextEditQuantity,
        ),
    )

    def normalize(self, archive, logger):
        super().normalize(archive, logger)
        if (
            hasattr(self, 'reference')
            and self.reference is not None
            and hasattr(self, 'sample_id')
        ):
            # xrd_context = ServerContext(
            #     get_upload_with_read_access(
            #         archive.m_context.upload_id,
            #         User(
            #             is_admin=True,
            #             user_id=archive.metadata.main_author.user_id,
            #         ),
            #         include_others=True,
            #     )
            # )

            with archive.m_context.raw_file(
                self.reference.m_parent.metadata.mainfile, 'r'
            ) as xrd_file:
                updated_xrd_file = json.load(xrd_file)
                updated_xrd_file['data']['samples'] = [
                    CompositeSystemReference(
                        lab_id=self.sample_id,
                    ).m_to_dict()
                ]

            create_archive(
                updated_xrd_file,
                archive.m_context,
                self.reference.m_parent.metadata.mainfile,
                'json',
                logger,
                overwrite=True,
            )


class InSituCharacterizationMbePDI(ArchiveSection):
    m_def = Section(
        a_h5web=H5WebAnnotation(
            paths=[
                'pyrometry/*/pyrometer_temperature',
                'laser_reflectance/*/laser_reflectance_intensity',
            ]
        ),
    )
    pyrometry = SubSection(
        section_def=Pyrometry,
        repeats=True,
    )
    laser_reflectance = SubSection(
        section_def=LaserReflectanceReference,
        repeats=True,
    )
    mass_spectrometry = SubSection(
        section_def=MassSpectrometryReference,
        repeats=True,
    )
    rheed = SubSection(
        section_def=RHEEDReference,
        repeats=True,
    )


class CharacterizationMbePDI(ArchiveSection):
    """
    A wrapped class to gather all the characterization methods in MBE
    """

    xrd = SubSection(
        section_def=XRDmeasurementReference,
        repeats=True,
    )
    hall = SubSection(
        section_def=HallMeasurementReference,
        repeats=True,
    )
    afm = SubSection(
        section_def=AFMmeasurementReference,
        repeats=True,
    )
    light_microscopy = SubSection(
        section_def=LiMimeasurementReference,
        repeats=True,
    )


class ShaftTemperature(Temperature):
    """
    Central shaft temperature (to hold the susceptor)
    """

    pass


class FilamentTemperature(Temperature):
    """
    heating filament temperature
    """

    pass


class LayTecTemperature(Temperature):
    """
    Central shaft temperature (to hold the susceptor)
    """

    pass


class PressurePDI(Pressure):
    """
    The pressure during the deposition process.
    """

    m_def = Section(a_h5web=H5WebAnnotation(axes='time', signal='value'))
    value = Quantity(
        type=HDF5Reference,
        shape=[],
    )
    time = Quantity(
        type=HDF5Reference,
        shape=[],
    )


class ChamberEnvironmentMbe(ChamberEnvironment):
    pressure = SubSection(
        section_def=PressurePDI,
        label='Pressure_1',
    )
    pressure_2 = SubSection(
        section_def=PressurePDI,
        label='Pressure_2',
    )
    bep = SubSection(
        section_def=PressurePDI,
        label='Beam Equivalent Pressure',
    )
    rotation = SubSection(
        section_def=Rotation,
    )
    heater = SubSection(
        section_def=SubstrateHeater,
    )


class SubstrateHeaterPower(TimeSeries):
    """
    The working output power measured from the substrate termocouple (dimensionless).
    """

    m_def = Section(a_h5web=H5WebAnnotation(axes='time', signal='value'))
    value = Quantity(
        type=HDF5Reference,
        unit='dimensionless',
        shape=[],
        a_h5web=H5WebAnnotation(
            long_name='power',
        ),
    )
    time = Quantity(
        type=HDF5Reference,
        description='The process time when each of the values were recorded.',
        shape=[],
    )


class SubstrateHeaterTemperature(TimeSeries):  # , PlotSection):
    """
    The temperature of the heater during the deposition process.
    """

    # m_def = Section(
    # a_h5web=H5WebAnnotation(
    #     axes=['pyro_time'], signal='pyro_value', auxiliary_signals=['value']
    # ),
    # a_eln={
    #     'hide': [
    #         'pyro_value',
    #         'pyro_time',
    #     ]
    # },
    # )

    value = Quantity(
        type=HDF5Reference,
        shape=[],
    )
    time = Quantity(
        type=HDF5Reference,
        description='The process time when each of the values were recorded.',
        shape=[],
    )

    # pyro_value = Quantity(
    #     type=HDF5Reference,
    #     shape=[],
    # )
    # pyro_time = Quantity(
    #     type=HDF5Reference,
    #     shape=[],
    # )

    # def normalize(self, archive, logger):
    #     super().normalize(archive, logger)
    #     #   plotly figure -----> HDF5Dataset solution:
    #     # ###
    #     with self.time as deserialized:
    #         time_array = deserialized[:]
    #     with self.value as deserialized:
    #         value_array = deserialized[:]
    #     with (
    #         archive.data.steps[0]
    #         .in_situ_characterization.pyrometry[0]
    #         .pyrometer_temperature.value as deserialized
    #     ):
    #         pyrometer_temperature = deserialized[:]
    #     with (
    #         archive.data.steps[0]
    #         .in_situ_characterization.pyrometry[0]
    #         .pyrometer_temperature.time as deserialized
    #     ):
    #         pyrometer_time = deserialized[:]

    #     # plotly figure -----> HDF5Reference solution:
    #     # ###
    #     time_array = HDF5Reference.read_dataset(archive, self.time)
    #     value_array = HDF5Reference.read_dataset(archive, self.value)
    #     pyrometer_time = HDF5Reference.read_dataset(
    #         archive,
    #         archive.data.steps[0]
    #         .in_situ_characterization.pyrometry[0]
    #         .pyrometer_temperature.time,
    #     )
    #     pyrometer_temperature = HDF5Reference.read_dataset(
    #         archive,
    #         archive.data.steps[0]
    #         .in_situ_characterization.pyrometry[0]
    #         .pyrometer_temperature.value,
    #     )

    #     # plotly figure
    #     # ###
    #     fig = go.Figure()
    #     fig.add_trace(
    #         go.Scatter(
    #             x=time_array,
    #             y=value_array,
    #             name='Sub Temp',
    #             line=dict(color='#2A4CDF', width=4),
    #             yaxis='y',
    #         ),
    #     )
    #     fig.add_trace(
    #         go.Scatter(
    #             x=pyrometer_time,
    #             y=pyrometer_temperature,
    #             name='Pyro Temp',
    #             line=dict(color='#90002C', width=2),
    #             yaxis='y',
    #         ),
    #     )
    #     fig.update_layout(
    #         template='plotly_white',
    #         dragmode='zoom',
    #         xaxis=dict(
    #             fixedrange=False,
    #             autorange=True,
    #             title='Process time / s',
    #             mirror='all',
    #             showline=True,
    #             gridcolor='#EAEDFC',
    #         ),
    #         yaxis=dict(
    #             fixedrange=False,
    #             title='Temperature / °C',
    #             tickfont=dict(color='#2A4CDF'),
    #             gridcolor='#EAEDFC',
    #         ),
    #         showlegend=True,
    #     )
    #     self.figures = [PlotlyFigure(label='figure 1', figure=fig.to_plotly_json())]

    #             fixedrange=False,
    #             title='Temperature / °C',
    #             tickfont=dict(color='#2A4CDF'),
    #             gridcolor='#EAEDFC',
    #         ),
    #         showlegend=True,
    #     )
    #     self.figures = [PlotlyFigure(label='figure 1', figure=fig.to_plotly_json())]


class SubstrateHeaterCurrent(TimeSeries):
    """
    The current of the heater during the deposition process.
    """

    m_def = Section(
        a_plot=[
            {
                'label': 'measured current',
                'x': 'time',
                'y': ['value'],
            },
        ],
        a_eln={
            'hide': [
                'set_value',
                'set_time',
            ]
        },
    )
    value = Quantity(
        type=float,
        unit='ampere',
        shape=['*'],
    )
    time = Quantity(
        type=Datetime,
        description='The process time when each of the values were recorded.',
        shape=['*'],
    )


class SubstrateHeaterVoltage(TimeSeries):
    """
    The voltage of the heater during the deposition process.
    """

    m_def = Section(
        a_plot=[
            {
                'label': 'measured voltage',
                'x': 'time',
                'y': ['value'],
            },
        ],
        a_eln={
            'hide': [
                'set_value',
                'set_time',
            ]
        },
    )
    value = Quantity(
        type=float,
        unit='volt',
        shape=['*'],
    )
    time = Quantity(
        type=Datetime,
        description='The process time when each of the values were recorded.',
        shape=['*'],
    )


class SampleParametersMbe(PVDSampleParameters):
    m_def = Section(
        a_h5web=H5WebAnnotation(paths=['substrate_temperature']),
    )
    name = Quantity(
        type=str,
        description="""
        Sample name.
        """,
        a_eln=ELNAnnotation(
            component='StringEditQuantity',
        ),
    )
    distance_to_source = Quantity(
        type=float,
        unit='meter',
        description="""
        The distance between the substrate and all the sources.
        In the case of multiple sources, the distances are listed in the same order
        as the sources are listed in the parent `VaporDepositionStep` section.
        """,
        shape=['*'],
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'millimeter'},
    )
    substrate_temperature = SubSection(
        section_def=SubstrateHeaterTemperature,
    )
    substrate_power = SubSection(
        section_def=SubstrateHeaterPower,
    )
    substrate_voltage = SubSection(
        section_def=SubstrateHeaterVoltage,
    )
    substrate_current = SubSection(
        section_def=SubstrateHeaterCurrent,
    )


class GrowthStepMbePDI(VaporDepositionStep, PlotSection):
    """
    Growth step for MBE PDI
    """

    m_def = Section(
        # label='Growth Step Mbe 2',
        a_eln=None,
    )

    name = Quantity(
        type=str,
        description="""
        A short and descriptive name for this step.
        """,
        a_eln=ELNAnnotation(
            component='StringEditQuantity',
            label='Step name',
        ),
    )
    step_index = Quantity(
        type=str,
        description='the ID from RTG',
        a_eln={
            'component': 'StringEditQuantity',
        },
    )
    # duration = VaporDepositionStep.duration.m_copy()

    duration = Quantity(
        type=float,
        unit='second',
        a_eln=ELNAnnotation(
            component='NumberEditQuantity',
        ),
    )

    comment = Quantity(
        type=str,
        description='description',
        a_eln={'component': 'StringEditQuantity'},
        label='Notes',
    )
    sample_parameters = SubSection(
        section_def=SampleParametersMbe,
        repeats=True,
    )
    sources = SubSection(
        section_def=SourcePDI,
        repeats=True,
    )
    environment = SubSection(
        section_def=ChamberEnvironmentMbe,
    )

    in_situ_characterization = SubSection(section_def=InSituCharacterizationMbePDI)


class GrowthStepMbeManualMetadataPDI(ProcessStep):
    """
    Some manually filled in metadata for the growth process.
    """

    m_def = Section(
        a_eln=ELNAnnotation(
            properties=SectionProperties(
                order=[
                    'name',
                    'datetime',
                    'end_time',
                    'duration',
                ]
            ),
        ),
    )
    end_time = Quantity(
        type=Datetime,
        description='The date and time when this process was finished.',
        a_eln=dict(component='DateTimeEditQuantity', label='ending time'),
    )


class GrowthMbeManualMetadataPDI(Process):
    """
    Some manually filled in metadata for the growth process.
    """

    m_def = Section(
        a_eln=ELNAnnotation(
            hide=[
                'name',
                'method',
                'datetime',
                'end_time',
                'lab_id',
                'location',
                'description',
                'samples',
                'instruments',
            ]
        )
    )
    steps = SubSection(
        section_def=GrowthStepMbeManualMetadataPDI,
        description="""
        An ordered list of all the steps that make up the growth run process.
        """,
        repeats=True,
    )


class GrowthMbePDI(VaporDeposition, PlotSection, EntryData):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section(
        a_eln=ELNAnnotation(
            properties=SectionProperties(
                order=[
                    'name',
                    'method',
                    'data_file',
                    'datetime',
                    'end_time',
                    'duration',
                ],
            ),
            # hide=[
            #     'sub_value',
            #     'sub_time',
            #     'pyro_value',
            #     'pyro_time',
            # ],
        ),
        label_quantity='lab_id',
        categories=[PDIMBECategory],
        label='Growth Process',
        # a_h5web=H5WebAnnotation(
        #     paths=[
        #         'steps/0/sources/*/impinging_flux/*',
        #     ]
        # ),
    )

    method = Quantity(
        type=str,
        default='MBE PDI',
    )
    datetime = Quantity(
        type=Datetime,
        description='The date and time when this activity was started.',
        a_eln=dict(component='DateTimeEditQuantity', label='starting time'),
    )  # this is added to correct the typo in the label from basesections.py
    tags = Quantity(
        type=str,
        shape=['*'],
        description='Searchable tags for this entry. Use Explore tab for searching.',
        a_eln=ELNAnnotation(
            component='StringEditQuantity',
        ),
    )
    data_file = Quantity(
        type=str,
        description='Upload here the spreadsheet file containing the deposition control data',
        # a_tabular_parser={
        #     "parsing_options": {"comment": "#"},
        #     "mapping_options": [
        #         {
        #             "mapping_mode": "row",
        #             "file_mode": "multiple_new_entries",
        #             "sections": ["#root"],
        #         }
        #     ],
        # },
        a_browser={'adaptor': 'RawFileAdaptor'},
        a_eln={'component': 'FileEditQuantity'},
    )
    description = Quantity(
        type=str,
        description='description',
        a_eln={'component': 'StringEditQuantity'},
        label='Notes',
    )
    lab_id = Quantity(
        type=str,
        description="""
        The ID found in Messages.txt raw file.
        It is composed by the Growth Run ID and the Sample Holder ID.
        """,
        a_eln=dict(component='StringEditQuantity', label='Growth process ID'),
    )
    # recipe_id = Quantity(
    #     type=str,
    #     description='the ID from RTG',
    #     a_tabular={'name': 'GrowthRun/Recipe Name'},
    #     a_eln={'component': 'StringEditQuantity', 'label': 'Recipe ID'},
    # )
    steps = SubSection(
        section_def=GrowthStepMbePDI,
        repeats=True,
    )
    shutters = SubSection(
        section_def=Shutter,
        repeats=True,
    )
    samples = SubSection(
        section_def=CompositeSystemReference,
        repeats=True,
    )

    def normalize(self, archive, logger):
        # for sample in self.samples:
        #     sample.normalize(archive, logger)
        # for parent_sample in self.parent_sample:
        #     parent_sample.normalize(archive, logger)
        # for substrate in self.substrate:
        #     substrate.normalize(archive, logger)

        # plotly figure list
        self.figures = []
        
        # plotly gas flows figure:
        fig = go.Figure()
        # Define custom tick values and labels
        tickvals_y = []
        ticktext_y = []
        for sources_index in range(len(self.steps[0].sources)):
            if len(self.steps[0].sources[sources_index].impinging_flux) > 0:
                current_rgb = random_rgb()
                rgb_10 = f'rgba({current_rgb}, 1)'
                if self.steps[0].sources[sources_index].impinging_flux[0].value is not None:
                    if self.steps[0].sources[sources_index].impinging_flux[0].time is not None:
                        timestamp_array = hdf5_2_datetime(archive, f"{self.steps[0].sources[sources_index].impinging_flux[0].time.rsplit("/", 1)[0]}/timestamp") # fetch the hdf5 dataset from the already used path for time
                        value_array = HDF5Reference.read_dataset(
                            archive, self.steps[0].sources[sources_index].impinging_flux[0].value
                        )
                        # Add baseline for each shutter
                        fig.add_trace(
                            go.Scatter(
                                x=timestamp_array,
                                y=[1 * sources_index for _ in value_array],
                                mode='lines',
                                name=f"{self.steps[0].sources[sources_index].primary_flux_species.name}" if self.steps[0].sources[sources_index].primary_flux_species is not None else "No name",
                                line=dict(color=rgb_10, width=2),
                                showlegend=False, 
                            ),
                        )
                        max_y = np.max(value_array)
                        fig.add_trace(
                            go.Scatter(
                                x=timestamp_array,
                                y=[value/max_y + 1 * sources_index for value in value_array],
                                mode='markers+lines',
                                name=f"{self.steps[0].sources[sources_index].primary_flux_species.name}" if self.steps[0].sources[sources_index].primary_flux_species is not None else "No name",
                                line=dict(color=rgb_10, width=2),
                                line_shape='hv',
                                fill='tonexty',
                            ),
                        )

                        # Define custom tick values and labels
                        tickvals_y.append(1 * sources_index + 1) 
                        ticktext_y.append(f"{max_y:.2e}")

                        fig.update_layout(
                            template='plotly_white',
                            dragmode='zoom',
                            xaxis=dict(
                                fixedrange=False,
                                autorange=True,
                                title='Timestamp',
                                mirror='all',
                                showline=True,
                                gridcolor='#EAEDFC',
                            ),
                            yaxis=dict(
                                fixedrange=False,
                                title='Gas flows',
                                tickfont=dict(color='#2A4CDF'),
                                gridcolor='#EAEDFC',
                                tickvals=tickvals_y, 
                                ticktext=ticktext_y,
                            ),
                            showlegend=True,
                        )
        self.figures.append(
            PlotlyFigure(
                label='Gas flows ',
                figure=fig.to_plotly_json(),
            )
        )

        # plotly temperature figure with HDF5Reference arrays:
        sub_time = self.steps[0].sample_parameters[0].substrate_temperature.time
        sub_value = self.steps[0].sample_parameters[0].substrate_temperature.value
        pyro_time = (
            self.steps[0]
            .in_situ_characterization.pyrometry[0]
            .pyrometer_temperature.time
        )
        pyro_value = (
            self.steps[0]
            .in_situ_characterization.pyrometry[0]
            .pyrometer_temperature.value
        )
        if (
            sub_time is not None
            and sub_value is not None
            and pyro_time is not None
            and pyro_value is not None
        ):

            timestamp_array = hdf5_2_datetime(archive, f"{sub_time.rsplit("/", 1)[0]}/timestamp") # fetch the hdf5 dataset from the already used path for time
            value_array = HDF5Reference.read_dataset(archive, sub_value)
            
            pyrometer_timestamp = hdf5_2_datetime(archive, f"{pyro_time.rsplit("/", 1)[0]}/timestamp") # fetch the hdf5 dataset from the already used path for time
            pyrometer_temperature = HDF5Reference.read_dataset(archive, pyro_value)

            # plotly temperature figure
            fig = go.Figure()
            fig.add_trace(
                go.Scatter(
                    x=timestamp_array,
                    y=value_array,
                    name='Sub Temp',
                    line=dict(color='#2A4CDF', width=4),
                    yaxis='y',
                ),
            )
            fig.add_trace(
                go.Scatter(
                    x=pyrometer_timestamp,
                    y=pyrometer_temperature,
                    name='Pyro Temp',
                    line=dict(color='#90002C', width=2),
                    yaxis='y',
                ),
            )
            fig.update_layout(
                template='plotly_white',
                dragmode='zoom',
                xaxis=dict(
                    fixedrange=False,
                    autorange=True,
                    title='Timestamp',
                    mirror='all',
                    showline=True,
                    gridcolor='#EAEDFC',
                ),
                yaxis=dict(
                    fixedrange=False,
                    title='Temperature / °C',
                    tickfont=dict(color='#2A4CDF'),
                    gridcolor='#EAEDFC',
                ),
                showlegend=True,
            )
            self.figures.append(
                PlotlyFigure(label='Temperature', figure=fig.to_plotly_json())
            )

        # plotly shutters figure:
        if self.shutters is not None:
            fig = go.Figure()
            for index, shutter in enumerate(self.shutters):
                current_rgb = random_rgb()
                rgb_10 = f'rgba({current_rgb}, 1)'
                # rgb_07 = f'rgba({current_rgb}, 0.7)'
                if shutter.shutter_status is not None:
                    if (
                        shutter.shutter_status.timestamp is not None
                        and shutter.shutter_status.value is not None
                    ):
                        # Add lines at each point
                        # for j in shutter.shutter_status.timestamp:
                        #     fig.add_shape(
                        #         type='line',
                        #         x0=j,
                        #         y0=0,
                        #         x1=j,
                        #         y1=1 + 1 * index,
                        #         line=dict(color='rgba(0,0,0, 1)', width=1),
                        #     )
                        # Add baseline for each shutter
                        fig.add_trace(
                            go.Scatter(
                                x=shutter.shutter_status.timestamp,
                                y=[1 * index for _ in shutter.shutter_status.value],
                                mode='lines',
                                name=shutter.name,
                                line=dict(color=rgb_10, width=2),
                                showlegend=False, 
                            ),
                        )
                        fig.add_trace(
                            go.Scatter(
                                x=shutter.shutter_status.timestamp,
                                y=[value + 1 * index
                                    for value in shutter.shutter_status.value],
                                mode='markers+lines',
                                name=shutter.name,
                                line=dict(color=rgb_10, width=2),
                                line_shape='hv',
                                fill='tonexty',
                            ),
                        )
                        # # Add rectangles between each pair of points
                        # for i in range(len(shutter.shutter_status.timestamp) - 1):
                        #     if shutter.shutter_status.value[i] == 0:
                        #         continue
                        #     if shutter.shutter_status.value[i] == 1:
                        #         fig.add_shape(
                        #             type='rect',
                        #             x0=shutter.shutter_status.timestamp[i],
                        #             y0=1 + 1 * index,
                        #             x1=shutter.shutter_status.timestamp[i + 1],
                        #             y1=0 + 1 * index,
                        #             fillcolor=rgb_07,
                        #             line=dict(color=rgb_10, width=2),
                        #             layer='above',
                        #         )
                        #         continue

            # Define custom tick values and labels
            # tickvals = self.shutters[0].shutter_status.timestamp
            # ticktext = [shutter.shutter_status.timestamp]

            fig.update_shapes(dict(xref='x', yref='y'))
            fig.update_layout(
                template='plotly_white',
                dragmode='zoom',
                xaxis=dict(
                    fixedrange=False,
                    autorange=True,
                    title='Timestamp',
                    mirror='all',
                    showline=True,
                    gridcolor='#EAEDFC',
                    #tickvals=tickvals,  # Set custom tick values
                    # ticktext=ticktext,  # Set custom tick labels
                ),
                yaxis=dict(
                    fixedrange=False,
                    title='Shutter status',
                    tickfont=dict(color='#2A4CDF'),
                    gridcolor='#EAEDFC',
                ),
                showlegend=True,
                legend=dict(
                    itemsizing='constant',  # Ensures the size of the legend items is constant
                    itemwidth=40,  # Adjust the width of the legend items
                ),
                legend_traceorder='reversed',
            )

            self.figures.append(
                PlotlyFigure(label='Shutters', figure=fig.to_plotly_json())
            )

        # workflow normalization
        archive.workflow2 = None
        super().normalize(archive, logger)
        if self.steps is not None:
            inputs = []
            outputs = []
            for step in self.steps:
                if step.sample_parameters is not None:
                    for sample in step.sample_parameters:
                        if sample.layer is not None:
                            outputs.append(
                                Link(
                                    name=f'{sample.layer.name}',
                                    section=sample.layer.reference,
                                )
                            )
                        if sample.substrate is not None:
                            outputs.append(
                                Link(
                                    name=f'{sample.substrate.name}',
                                    section=sample.substrate.reference,
                                )
                            )
                        if (
                            sample.substrate is not None
                            and sample.substrate.reference is not None
                        ):
                            if hasattr(
                                getattr(sample.substrate.reference, 'substrate'),
                                'name',
                            ):
                                # sample.substrate.reference.substrate.reference is not None:
                                inputs.append(
                                    Link(
                                        name=f'{sample.substrate.reference.substrate.name}',
                                        section=getattr(
                                            sample.substrate.reference.substrate,
                                            'reference',
                                            None,
                                        ),
                                    )
                                )
            archive.workflow2.outputs.extend(set(outputs))
            archive.workflow2.inputs.extend(set(inputs))


class SampleCutPDIReference(ActivityReference):
    """
    A section used for referencing a SampleCutPDI.
    """

    m_def = Section(
        label='SampleCutReference',
    )
    reference = Quantity(
        type=SampleCutPDI,
        description='A reference to a NOMAD `SampleCutPDI` entry.',
        a_eln=ELNAnnotation(
            component='ReferenceEditQuantity',
        ),
    )


class GrowthMbePDIReference(ActivityReference):
    """
    A section used for referencing a GrowthMbePDI.
    """

    m_def = Section(
        label='GrowthProcessReference',
    )
    reference = Quantity(
        type=GrowthMbePDI,
        description='A reference to a NOMAD `GrowthMbePDI` entry.',
        a_eln=ELNAnnotation(
            component='ReferenceEditQuantity',
        ),
    )
    lab_id = Quantity(
        type=str,
        description="""
        The readable identifier for the activity.
        """,
        a_eln=ELNAnnotation(
            component=ELNComponentEnum.StringEditQuantity,
            label='Growth process ID',
        ),
    )


class ExperimentMbePDI(Experiment, EntryData):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section(
        # a_eln={"hide": ["steps"]},
        categories=[PDIMBECategory],
        label='Experiment MBE',
        a_eln=ELNAnnotation(
            properties=SectionProperties(
                order=[
                    'name',
                    'lab_id',
                ]
            ),
            hide=[
                'datetime',
            ],
        ),
    )

    method = Quantity(
        type=str,
    )
    tags = Quantity(
        type=str,
        shape=['*'],
        description='Searchable tags for this entry. Use Explore tab for searching.',
        a_eln=ELNAnnotation(
            component='StringEditQuantity',
        ),
    )
    target_material = Quantity(
        type=str,
        shape=['*'],
        a_eln=ELNAnnotation(
            component='StringEditQuantity',
        ),
    )
    lab_id = Quantity(
        type=str,
        description="""
        ID of the growth run to be referenced in this experiment.
        It can be found in the Messages.txt raw file.
        """,
        a_eln=ELNAnnotation(
            component='StringEditQuantity',
            label='Growth process ID',
        ),
    )
    growth_run_logfiles = SubSection(
        section_def=GrowthMbePDIReference,
    )
    growth_run_steps = SubSection(
        section_def=GrowthMbeManualMetadataPDI,
    )
    substrate_holder = SubSection(
        section_def=FilledSubstrateHolderPDIReference,
    )
    samples = SubSection(
        section_def=CompositeSystemReference,
        repeats=True,
    )
    characterization = SubSection(section_def=CharacterizationMbePDI)

    steps = SubSection(
        section_def=ActivityReference,
        repeats=True,
    )

    def normalize(self, archive, logger):
        archive_sections = (
            attr
            for attr in vars(self).values()
            if isinstance(attr, ArchiveSection) and not isinstance(attr, EntryArchive)
            # not isinstance(attr, EntryArchive) avoid including Experiment itself
        )
        step_list = []
        for section in archive_sections:
            try:
                if section is not None:
                    step_list.extend(handle_section(section))
            except (AttributeError, TypeError, NameError) as e:
                print(f'An error occurred in section XXX {section}: {e}')
        self.steps = [step for step in step_list if step is not None]

        activity_lists = (
            attr for attr in vars(self).values() if isinstance(attr, list)
        )
        for activity_list in activity_lists:
            for activity in activity_list:
                if isinstance(activity, ArchiveSection):
                    try:
                        step_list.extend(handle_section(activity))
                    except (AttributeError, TypeError, NameError) as e:
                        print(f'An error occurred in section YYY {section}: {e}')
        self.steps = [step for step in step_list if step is not None]

        archive.workflow2 = None
        super().normalize(archive, logger)

        # fill lab_id if exp is linked to growth archive
        if self.growth_run_logfiles is not None:
            if self.growth_run_logfiles.reference:
                growth_id = self.growth_run_logfiles.reference.lab_id
                growth_ref = link_growth_process(archive, growth_id, logger)
                if growth_id is not None:
                    self.lab_id = growth_id
                if growth_ref is not None:
                    self.growth_run_logfiles = GrowthMbePDIReference(
                        reference=growth_ref
                    )

        # link to growth archive if lab_id is filled in exp
        if self.lab_id is not None and self.growth_run_logfiles is None:
            growth_ref = link_growth_process(archive, self.lab_id, logger)
            if growth_ref is not None:
                self.growth_run_logfiles = GrowthMbePDIReference(reference=growth_ref)
                self.growth_run_logfiles.normalize(archive, logger)

        # setting the sample status
        if self.substrate_holder:
            if self.substrate_holder.reference:
                for sample_holder_position in self.substrate_holder.reference.positions:
                    if sample_holder_position.substrate:
                        set_sample_status(
                            sample_holder_position.substrate.reference,
                            logger,
                            as_delivered=False,
                            fresh=False,
                            processed=sample_holder_position.substrate.reference.grown
                            if sample_holder_position.substrate.reference.grown
                            else False,
                            grown=True,
                        )

        # create samples archives
        if (
            self.growth_run_logfiles is not None
            and self.substrate_holder is not None
            and not self.samples
        ):
            if self.substrate_holder.reference:
                growth_id = self.growth_run_logfiles.reference.lab_id
                self.samples = []
                for sample_holder_position in self.substrate_holder.reference.positions:
                    if sample_holder_position.substrate:
                        sample_id = f'{growth_id}_{sample_holder_position.name}'
                        sample_object = ThinFilmStackMbePDI(
                            name=sample_holder_position.substrate.name,
                            lab_id=sample_id,
                            substrate=SubstrateReference(
                                reference=sample_holder_position.substrate.reference
                            )
                        )
                        filetype = 'yaml'
                        sample_filename = f'{sample_id}.archive.{filetype}'
                        
                        sample_archive = EntryArchive(
                            m_context=archive.m_context,
                            data=sample_object,
                        )
                        self.samples.append(
                            CompositeSystemReference(
                                reference=create_archive(
                            sample_archive.m_to_dict(),
                            archive.m_context,
                            sample_filename,
                            filetype,
                            logger,
                        ),
                        ))


        

        # search_result = search(
        #     owner="user",
        #     query={
        #         "results.eln.sections:any": ["GrowthMbe1PDIConstantParameters"],
        #         "upload_id:any": [archive.m_context.upload_id],
        #     },
        #     pagination=MetadataPagination(page_size=10000),
        #     user_id=archive.metadata.main_author.user_id,
        # )
        # # checking if all entries are properly indexed
        # if getattr(
        #     getattr(self, "growth_run_constant_parameters", None), "lab_id", None
        # ) and not getattr(
        #     getattr(self, "growth_run_constant_parameters", None), "reference", None
        # ):
        #     found_id = False
        #     for growth_entry in search_result.data:
        #         if (
        #             self.growth_run_constant_parameters.lab_id
        #             == growth_entry["results"]["eln"]["lab_ids"][0]
        #         ):
        #             found_id = True
        #             self.growth_run_constant_parameters = GrowthMbe1PDIConstantParametersReference(
        #                 reference=f"../uploads/{archive.m_context.upload_id}/archive/{growth_entry['entry_id']}#data"
        #             )
        #         for search_quantities in growth_entry["search_quantities"]:
        #             if (
        #                 search_quantities["path_archive"]
        #                 == "data.substrate_temperature"
        #             ):
        #                 self.substrate_temperature = search_quantities["float_value"]
        #             if search_quantities["path_archive"] == "data.oxygen_argon_ratio":
        #                 self.oxygen_argon_ratio = search_quantities["float_value"]
        #             if search_quantities["path_archive"] == "data.composition":
        #                 self.composition = search_quantities["str_value"][0]
        #     if not found_id:
        #         logger.warning(
        #             f"The lab_id '{self.growth_run_constant_parameters.lab_id}' was not found in any 'GrowthMbe1PDIConstantParameters' entry in Nomad. Check if it exist and try to reference it manually."
        #         )
        # else:
        #     logger.warning(
        #         "No lab_id for 'GrowthMbe1PDIConstantParameters' found. The archive couldn't be referenced."
        #     )

    # def normalize(self, archive, logger: BoundLogger) -> None:
    #     '''
    #     The normalizer for the `MbeBinaryOxidesPDIExperiment` class.
    #     '''
    #     super(MbeBinaryOxidesPDIExperiment, self).normalize(archive, logger)
    ## Potential weak code in next lines:
    ## I want to get back to GrowthRun entry (already created by tabular parser)
    ## and set the "reference" quantity in grwon_samples.
    ## Here two example codes by Theodore Chang, first touches the raw file, second touches the processed file.
    #### ONE
    ## 1. get the file name of archive/entry containing grown_sample_ref
    ## 2. overwrite yaml for this entry
    ## 3. reprocess
    # grown_sample_ref.reference = f'../uploads/{archive.m_context.upload_id}/archive/{hash(archive.m_context.upload_id, filename)}#data'
    # grown_sample_archive = grown_sample_ref
    # while not isinstance(grown_sample_archive, EntryArchive):
    #     grown_sample_archive=grown_sample_archive.m_parent
    # grown_sample_file_name:str = grown_sample_archive.metadata.mainfile
    # create_archive(
    #     grown_sample_archive.m_to_dict(), archive.m_context, grown_sample_file_name, filetype, logger,bypass_check=True)
    #### TWO
    ## alternatively directly overwite the processed msg file
    # grown_sample_upload_id:str = grown_sample_archive.metadata.upload_id
    # grown_sample_entry_id:str = grown_sample_archive.metadata.entry_id
    # StagingUploadFiles(grown_sample_upload_id).write_archive(grown_sample_entry_id, grown_sample_archive.m_to_dict())


m_package.__init_metainfo__()
